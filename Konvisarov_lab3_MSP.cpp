#include <bits/stdc++.h>
using namespace std;
#define N 5//количество вершин
#define INFINITE 1000000//подобие бесконечности

struct edge {//структура наших путей
	int otkuda, kuda, ves;//думаю по названию понятно что есть что
};

void algoritm(vector<edge>graf,int Matrix[N]){//функция,принимает вектор(инфо о путях) и массив(конечный результат наших путей)
    for(int k=0;k<N;k++){//обезопасил себя , по идее количество этапов совпадает с количеством вершин
        for (int i = 0; i < N; i++)//цикл вывода на экран
            {
            cout<<Matrix[i]<<" ";//соответственно вывод на экран
            }
        cout<<"\n";//новая строка

        for (int i = 0; i < N+1; i++)//цикл до N+1,потому что у нас столько путей (это чисто для данного случая,можно было бы использовать альтернативу(смотрите ниже))
        //for(int i=0;i<graf.size();i++)
        {
            if(Matrix[graf[i].kuda-1]-Matrix[graf[i].otkuda-1]>graf[i].ves){//сам алгоритм, если вес вершины[КУДА]-веса вершины[ОТКУДА]>веса дуги между ними
                Matrix[graf[i].kuda-1]=graf[i].ves+Matrix[graf[i].otkuda-1];//то вес вершины[КУДА]=вес дуги между ними + вес вершины[ОТКУДА]
                //почему везде -1 , потому что счет массива идёт с нуля
            }
        }
    }
    cout<<"okoncatelnii put':\n"<<"5";//надпись,потому что с самого начала нужно поставить путь откуда
        for (int j = 0; j < N; j++)//цикл по количеству,на всякий случай 
        {
            for (int i = 0; i < N+1; i++)//цикл до N+1,потому что у нас столько путей (это чисто для данного случая,можно было бы использовать альтернативу(смотрите ниже))
            //for(int i=0;i<graf.size();i++)
            {
                if(Matrix[N-1]-Matrix[graf[i].otkuda-1]==graf[i].ves)//если последний конечный вес в точку,которая нам нужна - вес вершины откуда исходит в него дуга равна дуге
                {   
                    cout<<" -> ";
                    Matrix[N-1]-=graf[i].ves;//тогда конечный вес изминяется 
                    cout<<graf[i].otkuda;}//и просто выводится на экран та вершина по которой прошел путь
                    
                    //можно было сделать для данного случая цикл обратный ,потому что пути расположены чисто по порядку(сначала из 1-й вершины,потом 2-й 3-й 4-й) 
                    //но я сделал для общего случая
            }
        }
        cout<<"\n";

}

int main(){
vector<edge>graf; //создаем векторные структуры
//добавляем пути по принципу откуда куда и их вес
graf.push_back({1,2,3});
graf.push_back({2,3,2});
graf.push_back({2,5,7});
graf.push_back({2,4,1});
graf.push_back({3,4,5});
graf.push_back({4,5,3});
int Matrix[N];//создаем матрицу для веса вершин
for (int i = 0; i < N; i++)//цикл
{
    Matrix[i]=INFINITE;//по дефолту должны быть все бесконечности расставлены
}
Matrix[0]=0;//кроме первого элемента , чтоб пошел процесс
algoritm(graf,Matrix);
return 0;

}